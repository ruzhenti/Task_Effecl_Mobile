"""
Блок 2: Python
Задание 1: Изоморфизмы

Реализовать функцию (или тело функции), которая проверяет на изоморфность два слова.
Пояснение: строки s и t называются изоморфными, если все вхождения каждого символа строки s
можно последовательно заменить другим символом и получить строку t. Порядок символов при этом
должен сохраняться, а замена — быть уникальной. Так, два разных символа строки s нельзя заменить
одним и тем же символом из строки t, а вот одинаковые символы в строке s должны заменяться
одним и тем же символом.

Пример:
s = 'paper' 
t = 'title' 
print(is_isomorphic(s, t))
# Вывод: 
True

Оценить оптимальность решения по времени и памяти и прикрепить текст кода.
"""
def is_isomorphic(s: str, t: str) -> bool:
    """
    Проверяем, являются ли две строки изоморфными.    
    а. Если длины строк не совпадают, они не могут быть изоморфными
    б. Используем два словаря для отслеживания соответствий:
       - s_to_t: отображение символов из s в символы из t
       - t_to_s: отображение символов из t в символы из s
    с. Для каждой позиции проверяем:
       - Если символ из s уже был сопоставлен с другим символом из t -> False
       - Если символ из t уже был сопоставлен с другим символом из s -> False         
    """
    if len(s) != len(t):
        return False
    
    # Определим словари для отслеживания соответствий
    s_to_t = {}  
    t_to_s = {}  
    
    for i in range(len(s)):
        char_s = s[i]
        char_t = t[i]
        
        # Проверяем соответствие s -> t
        if char_s in s_to_t:
            if s_to_t[char_s] != char_t:
                return False
        else:
            s_to_t[char_s] = char_t
        
        # Проверяем соответствие t -> s 
        if char_t in t_to_s:
            if t_to_s[char_t] != char_s:
                return False
        else:
            t_to_s[char_t] = char_s
    
    return True
if __name__ == "__main__":
    # Тестовые примеры
    s1, t1 = 'paper', 'title'
    print(f"is_isomorphic('{s1}', '{t1}') = {is_isomorphic(s1, t1)}")  # True
    
    s2, t2 = 'foot', 'bolt'
    print(f"is_isomorphic('{s2}', '{t2}') = {is_isomorphic(s2, t2)}")  # False
    
    s3, t3 = 'add', 'bad'
    print(f"is_isomorphic('{s3}', '{t3}') = {is_isomorphic(s3, t3)}")  # False
    
    s4, t4 = 'tank', 'rang'
    print(f"is_isomorphic('{s4}', '{t4}') = {is_isomorphic(s4, t4)}")  # True   
"""
check
is_isomorphic('paper', 'title') = True
is_isomorphic('foot', 'bolt') = False
is_isomorphic('add', 'bad') = False
is_isomorphic('tank', 'rang') = True
"""

"""
Задание 2: Натуральная последовательность

Реализовать функцию (или тело функции), которая находит единственное отсутствующее число
из последовательности натуральных чисел 1,2,…,n.

Пример:
nums = [1, 2, 3, 4, 5, 6, 8, 9, 10, 11]
print(missing_number(nums))
# Вывод: 
7

Оценить оптимальность решения по времени и памяти и прикрепить текст кода.
"""
def missing_number(nums):
    """
    Ищем единственное отсутствующее число в последовательности натуральных чисел 1..n.
    
    Алгоритм:
    Сумма арифметической прогрессии от 1 до n: S = n * (n + 1) / 2
    Если в массиве отсутствует одно число, то:
    - Считаем сумму всех чисел в массиве
    - Вычисляем ее для последовательности 1..n
    - Разница дает нам отсутствующее число
    """
def missing_number(nums):
    """
    Сумма арифметической прогрессии от 1 до n: S = n * (n + 1) / 2
    Если в массиве отсутствует одно число, то:
    - Находим сумму всех чисел в массиве
    - Вычисляем ожидаемую сумму для последовательности 1..n
    - Разница даст нам отсутствующее число       
    """
    if not nums:
        return None
    
    # максимальное число в массиве
    n = max(nums)
    
    # ожидаемая сумму последовательности 
    expected_sum = n * (n + 1) // 2
    
    # фактическая сумма чисел в массиве
    actual_sum = sum(nums)
    
    # отсутствующее число
    missing = expected_sum - actual_sum
    
    return missing   
if __name__ == "__main__":
    # Тестовые примеры
    nums1 = [1, 2, 3, 4, 5, 6, 8, 9, 10, 11]
    result1 = missing_number(nums1)
    print(f"missing_number({nums1}) = {result1}")  # 7
    
    nums2 = [1, 2, 3, 5]
    result2 = missing_number(nums2)
    print(f"missing_number({nums2}) = {result2}")  # 4
    
    nums3 = [2, 3, 4, 5]
    result3 = missing_number(nums3)
    print(f"missing_number({nums3}) = {result3}")  # 1   
"""
check
missing_number([1, 2, 3, 4, 5, 6, 8, 9, 10, 11]) = 7
missing_number([1, 2, 3, 5]) = 4
missing_number([2, 3, 4, 5]) = 1
"""

""
Задание 3: Факторизация

Реализовать функцию (или тело функции), которая при введении натурального числа n
разбивает его на простые множители (представить его в виде простых чисел).

Пример:
n = 56
print(prime_factors(n))
# Вывод:
[2, 2, 2, 7]

Оценить оптимальность решения по времени и памяти и прикрепить текст кода.
"""
def prime_factors(n):
    """
    а. Проверяем делимость на 2 
    б. Проверяем делимость на нечетные числа от 3 до sqrt(n)
    с. Если после всех делений осталось число > 1, оно тоже простое   
    """
    if n < 2:
        return []
    
    factors = []
    
    # делимость на 2
    while n % 2 == 0:
        factors.append(2)
        n //= 2
    
    # делимость на нечетные числа 
    i = 3
    while i * i <= n:
        while n % i == 0:
            factors.append(i)
            n //= i
        i += 2
    
    # остатокот всех делений
    if n > 1:
        factors.append(n)
    
    return factors  
if __name__ == "__main__":
    # Тестовые примеры
    test_cases = [55, 11, 16, 99, 96, 4, 7]
    
    for n in test_cases:
        result = prime_factors(n)
        print(f"prime_factors({n}) = {result}")
    
    # пример из задания
    n = 56
    result = prime_factors(n)
    print(f"\nprime_factors({n}) = {result}")  # [2, 2, 2, 7]
"""
check
prime_factors(55) = [5, 11]
prime_factors(11) = [11]
prime_factors(16) = [2, 2, 2, 2]
prime_factors(99) = [3, 3, 11]
prime_factors(96) = [2, 2, 2, 2, 2, 3]
prime_factors(4) = [2, 2]
prime_factors(7) = [7]
prime_factors(56) = [2, 2, 2, 7]
"""
