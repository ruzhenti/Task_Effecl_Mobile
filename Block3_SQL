-- Блок 3: SQL
-- Задание 1: Абитуриенты
-- 
-- Есть таблица examination с двумя полями:
--   id (id абитуриента)
--   scores (кол-во набранных баллов дополнительного вступительного испытания от 0 до 100)
--
-- Требуется реализовать запрос, который создаёт колонку с позицией абитуриента в общем рейтинге.

-- Используем оконную функцию RANK() или ROW_NUMBER()
-- RANK() - если есть одинаковые баллы, они получают одинаковый ранг, следующий ранг пропускается
-- DENSE_RANK() - если есть одинаковые баллы, они получают одинаковый ранг, следующий ранг не пропускается
-- ROW_NUMBER() - каждому абитуриенту присваивается уникальный номер, даже при одинаковых баллах

-- Вариант 1: Использование RANK()
SELECT 
    id,
    scores,
    RANK() OVER (ORDER BY scores DESC) AS position
FROM examination;

-- Вариант 2: Использование ROW_NUMBER()
-- При одинаковых баллах порядок будет произвольным
SELECT 
    id,
    scores,
    ROW_NUMBER() OVER (ORDER BY scores DESC, id ASC) AS position
FROM examination;

-- Задание 2: FULL JOIN
--
-- Представьте две таблицы: первая содержит 30 строк, а вторая  20 строк.
-- Мы выполняем операцию FULL JOIN между ними.
-- Какой диапазон возможного количества строк может быть в результирующей таблице,
-- если учесть, что ключи для соединения могут быть как полностью совпадающими,
-- так и абсолютно уникальными?
--
-- Ответ дать в краткой форме, например: минимально 10 и максимально 3000 строк

/*
FULL JOIN возвращает все строки из обеих таблиц:
-- Если ключи совпадают - строки объединяются
-- Если ключ есть только в первой таблице - добавляется строка с NULL из второй
-- Если ключ есть только во второй таблице - добавляется строка с NULL из первой

-- Минимум: когда все ключи совпадают и уникальны, и все ключи из меньшей таблицы есть в большей
  Результат: 30 строк (все строки из большей таблицы)

-- Максимум: когда все ключи уникальны и не совпадают между таблицами
  Результат: 30 + 20 = 50 строк (все строки из обеих таблиц)

Ответ: минимально 30 и максимально 50 строк
*/
-- Пояснения
-- Случай 1: Все ключи совпадают (минимум)
-- Таблица A: 30 строк с ключами 1-30
-- Таблица B: 20 строк с ключами 1-20
-- FULL JOIN: 30 строк (все из A, 20 соединены с B, 10 с NULL)
-- Случай 2: Все ключи уникальны и не совпадают (максимум)
-- Таблица A: 30 строк с ключами 1-30
-- Таблица B: 20 строк с ключами 31-50
-- FULL JOIN: 50 строк (30 из A с NULL, 20 из B с NULL)

-- Случай 3: Частичное совпадение
-- Таблица A: 30 строк с ключами 1-30
-- Таблица B: 20 строк с ключами 15-34
-- FULL JOIN: 34 строки (1-14 из A, 15-30 соединены, 31-34 из B)
    /*
Ответ: минимально 30 и максимально 50 строк

-- Задание 3: Покупки
create table account
(
    id integer, -- ID счета
    client_id integer, -- ID клиента
    open_dt date, -- дата открытия счета
    close_dt date -- дата закрытия счета
)

create table transaction
(
    id integer,  -- ID транзакции
    account_id integer,  -- ID счета
    transaction_date date,  -- дата транзакции
    amount numeric(10,2), -- сумма транзакции
    type varchar(3) -- тип транзакции
)
--Вывести ID клиентов, которые за последний месяц по всем своим счетам совершили покупок меньше, 
--чем на 5000 рублей.
--Без использования подзапросов и оконных функций.

-- Имеем таблицы:
--   account (id, client_id, open_dt, close_dt)
--   transaction (id, account_id, transaction_date, amount, type)

-- Используем JOIN и GROUP BY с HAVING
-- Порядок действий
-- Предполагаем, что последний месяц - последние 30 дней)
-- Соединяем account и transaction по account_id
-- Фильтруем транзакции за последний месяц и только покупки (type = BUY или аналогичный)
-- Группируем по client_id
-- Суммируем amount и фильтруем по условию < 5000

-- Вариант 1: Если "последний месяц" означает последние 30 дней
SELECT 
    a.client_id
FROM account a
INNER JOIN transaction t ON a.account_id = t.account_id
WHERE 
    -- Транзакции за последние 30 дней
    t.transaction_date >= CURRENT_DATE - INTERVAL '30 days'
    AND t.transaction_date < CURRENT_DATE
    -- Только покупки
    AND t.type IN ('BUY', 'PUR', 'PURCHASE')  -- уточнить формат type
    -- Счет должен быть открыт на момент транзакции
    AND (a.close_dt IS NULL OR t.transaction_date <= a.close_dt)
    AND t.transaction_date >= a.open_dt
GROUP BY a.client_id
HAVING SUM(t.amount) < 5000;

-- Вариант 2: Более универсальный (если type может быть любым, но покупки - это положительные amount)
-- Или если покупки определяются по типу транзакции 
SELECT 
    a.client_id
FROM account a
INNER JOIN transaction t ON a.account_id = t.account_id
WHERE 
    -- Транзакции за последний календарный месяц
    t.transaction_date >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')
    AND t.transaction_date < DATE_TRUNC('month', CURRENT_DATE)
    -- Только покупки (предполагаем, что это транзакции с определенным типом)
    -- Если type = 'DEB' или отрицательные значения - это покупки, нужно уточнить
    AND t.type = 'DEB'  -- уточнить формат type для покупок
    -- Счет должен быть открыт на момент транзакции
    AND (a.close_dt IS NULL OR t.transaction_date <= a.close_dt)
    AND t.transaction_date >= a.open_dt
GROUP BY a.client_id
HAVING SUM(ABS(t.amount)) < 5000;

-- Примечания:
-- Используем только JOIN и GROUP BY без подзапросов и оконных функций
